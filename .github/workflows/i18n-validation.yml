name: Build and Test

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'Ritualist/**/*.swift'
      - 'RitualistTests/**/*.swift'
      - 'RitualistCore/**/*.swift'
      - 'Ritualist/Resources/**'
      - 'Ritualist.xcodeproj/**'
      - 'TestPlan.xctestplan'
      - '.github/workflows/**'
      - 'Scripts/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'Ritualist/**/*.swift'
      - 'RitualistTests/**/*.swift'
      - 'RitualistCore/**/*.swift'
      - 'Ritualist/Resources/**'
      - 'Ritualist.xcodeproj/**'
      - 'TestPlan.xctestplan'
      - '.github/workflows/**'
      - 'Scripts/**'

# Auto-cancel old runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  string-validation:
    name: Validate Localized Strings
    runs-on: macos-latest
    timeout-minutes: 10

    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.4'
    
    - name: Validate String Lengths
      run: swift Scripts/validate_strings.swift
      
    - name: Upload String Validation Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: string-validation-report
        path: string_validation_report.txt
        retention-days: 30

  build-test:
    name: Build and Test
    runs-on: macos-latest
    timeout-minutes: 45

    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.4'
    
    - name: Cache SwiftPM Dependencies
      uses: actions/cache@v4
      with:
        path: |
          .build
          ~/Library/Caches/org.swift.swiftpm
        key: ${{ runner.os }}-swiftpm-${{ hashFiles('**/Package.swift') }}-${{ hashFiles('**/Package.resolved') }}
        restore-keys: |
          ${{ runner.os }}-swiftpm-
    
    - name: Cache Xcode DerivedData
      uses: actions/cache@v4
      with:
        path: |
          ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-xcode-16.4-deriveddata-${{ hashFiles('Ritualist.xcodeproj/project.pbxproj') }}
        restore-keys: |
          ${{ runner.os }}-xcode-16.4-deriveddata-
    
    - name: Build for Testing (with timing)
      run: |
        echo "‚è±Ô∏è Starting build-for-testing at $(date)"
        BUILD_START=$(date +%s)

        xcodebuild build-for-testing \
          -project Ritualist.xcodeproj \
          -scheme Ritualist-AllFeatures \
          -destination 'platform=iOS Simulator,name=iPhone 16' \
          -configuration Debug-AllFeatures \
          -derivedDataPath ~/Library/Developer/Xcode/DerivedData

        BUILD_END=$(date +%s)
        BUILD_TIME=$((BUILD_END - BUILD_START))
        echo "‚úÖ Build completed in ${BUILD_TIME} seconds"
        echo "BUILD_TIME=${BUILD_TIME}" >> $GITHUB_ENV
    
    - name: Boot Simulator First
      run: |
        echo "üöÄ Booting simulator..."
        xcrun simctl boot "iPhone 16" || xcrun simctl boot "iPhone 15 Pro" || echo "Simulator already booted"
        xcrun simctl list devices | grep Booted

    - name: Run Tests (including Swift Testing)
      run: |
        echo "üß™ Starting tests at $(date)"
        TEST_START=$(date +%s)

        xcodebuild test-without-building \
          -project Ritualist.xcodeproj \
          -scheme Ritualist-AllFeatures \
          -destination 'platform=iOS Simulator,name=iPhone 16' \
          -only-testing:RitualistTests \
          -resultBundlePath TestResults.xcresult \
          -derivedDataPath ~/Library/Developer/Xcode/DerivedData \
          -enableCodeCoverage YES

        TEST_END=$(date +%s)
        TEST_TIME=$((TEST_END - TEST_START))
        echo "‚úÖ Tests completed in ${TEST_TIME} seconds"
        echo "TEST_TIME=${TEST_TIME}" >> $GITHUB_ENV
      
    - name: Calculate Code Coverage
      run: |
        if [ -d "TestResults.xcresult" ]; then
          echo "üìä Extracting code coverage data..."

          # Extract coverage JSON
          xcrun xccov view --report --json TestResults.xcresult > coverage.json 2>&1

          if [ $? -eq 0 ] && [ -s coverage.json ]; then
            echo "‚úÖ Coverage data extracted successfully"

            # Parse JSON and extract coverage percentages using jq (or Python if jq unavailable)
            if command -v jq &> /dev/null; then
              # Extract total coverage
              TOTAL_COVERAGE=$(jq -r '.lineCoverage' coverage.json 2>/dev/null || echo "0")

              # Convert to percentage (multiply by 100)
              TOTAL_COVERAGE_PCT=$(echo "$TOTAL_COVERAGE * 100" | bc -l 2>/dev/null || echo "0")
              TOTAL_COVERAGE_DISPLAY=$(printf "%.2f" $TOTAL_COVERAGE_PCT)

              echo "üìà Total Code Coverage: ${TOTAL_COVERAGE_DISPLAY}%"
              echo "COVERAGE_PERCENTAGE=${TOTAL_COVERAGE_DISPLAY}" >> $GITHUB_ENV

              # Create detailed coverage report
              cat > test_coverage_report.md << EOF
        # üìä Code Coverage Report

        ## Coverage Summary
        - **Total Coverage**: ${TOTAL_COVERAGE_DISPLAY}%

        ## Build Performance
        - **Build Time**: ${BUILD_TIME} seconds
        - **Test Time**: ${TEST_TIME} seconds
        - **Total CI Time**: $((BUILD_TIME + TEST_TIME)) seconds

        ## Coverage Details
        Full coverage data available in \`coverage.json\` artifact.

        ### Coverage Breakdown by Target
        EOF

              # Extract per-target coverage (targets array in JSON)
              jq -r '.targets[] | "- **\(.name)**: \((.lineCoverage * 100) | tostring)%"' coverage.json 2>/dev/null >> test_coverage_report.md || echo "- Coverage breakdown not available" >> test_coverage_report.md

              echo "" >> test_coverage_report.md
              echo "---" >> test_coverage_report.md
              echo "_Report generated on $(date -u '+%b %d, %Y at %H:%M:%S UTC')_" >> test_coverage_report.md

              echo "‚úÖ Coverage report generated with ${TOTAL_COVERAGE_DISPLAY}% total coverage"
            else
              echo "‚ö†Ô∏è jq not available - using basic coverage report"

              # Fallback: create basic report
              cat > test_coverage_report.md << EOF
        # üìä Code Coverage Report

        ## Build Performance
        - **Build Time**: ${BUILD_TIME} seconds
        - **Test Time**: ${TEST_TIME} seconds
        - **Total CI Time**: $((BUILD_TIME + TEST_TIME)) seconds

        ## Coverage Data
        Coverage data extracted but jq unavailable for parsing.
        Full coverage data available in \`coverage.json\` artifact.

        _Report generated on $(date -u '+%b %d, %Y at %H:%M:%S UTC')_
        EOF

              echo "COVERAGE_PERCENTAGE=N/A" >> $GITHUB_ENV
            fi
          else
            echo "‚ö†Ô∏è Coverage extraction failed or returned empty data"

            # Create fallback report
            cat > test_coverage_report.md << 'EOF'
        # üìä Code Coverage Report

        ## ‚ö†Ô∏è Coverage Data Unavailable

        Coverage extraction failed. This may happen if:
        - Tests failed to run
        - Code coverage was not enabled in the scheme
        - xcresult bundle is corrupted

        ## Build Performance
        EOF
            echo "- **Build Time**: ${BUILD_TIME} seconds" >> test_coverage_report.md
            echo "- **Test Time**: ${TEST_TIME} seconds" >> test_coverage_report.md
            echo "" >> test_coverage_report.md
            echo "_Report generated on $(date -u '+%b %d, %Y at %H:%M:%S UTC')_" >> test_coverage_report.md

            echo "COVERAGE_PERCENTAGE=N/A" >> $GITHUB_ENV
          fi
        else
          echo "‚ùå TestResults.xcresult not found - tests may have failed to run"
          echo "COVERAGE_PERCENTAGE=N/A" >> $GITHUB_ENV
        fi
          
    - name: Upload Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-and-coverage
        path: |
          TestResults.xcresult/
          coverage.json
          test_coverage_report.md
        retention-days: 30

  swiftlint:
    name: SwiftLint
    runs-on: macos-latest
    timeout-minutes: 10

    steps:
    - uses: actions/checkout@v4
    
    - name: Install SwiftLint
      run: brew install swiftlint
    
    - name: Run SwiftLint
      run: |
        cd Ritualist
        swiftlint --reporter github-actions-logging

  generate-report:
    name: Generate Build Report
    runs-on: macos-latest
    needs: [string-validation, build-test, swiftlint]
    if: always()
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts/
    
    - name: Generate Build Report
      run: |
        # Determine overall status
        STRING_STATUS="${{ needs.string-validation.result }}"
        BUILD_STATUS="${{ needs.build-test.result }}"
        LINT_STATUS="${{ needs.swiftlint.result }}"

        # Status emoji and text mapping
        get_status_emoji() {
          case $1 in
            success) echo "‚úÖ" ;;
            failure) echo "‚ùå" ;;
            cancelled) echo "‚ö†Ô∏è" ;;
            skipped) echo "‚è≠Ô∏è" ;;
            *) echo "‚ö†Ô∏è" ;;
          esac
        }

        get_status_text() {
          case $1 in
            success) echo "SUCCESS" ;;
            failure) echo "FAILED" ;;
            cancelled) echo "CANCELLED" ;;
            skipped) echo "SKIPPED" ;;
            *) echo "UNKNOWN" ;;
          esac
        }

        STRING_EMOJI=$(get_status_emoji "$STRING_STATUS")
        BUILD_EMOJI=$(get_status_emoji "$BUILD_STATUS")
        LINT_EMOJI=$(get_status_emoji "$LINT_STATUS")

        STRING_TEXT=$(get_status_text "$STRING_STATUS")
        BUILD_TEXT=$(get_status_text "$BUILD_STATUS")
        LINT_TEXT=$(get_status_text "$LINT_STATUS")

        # Check if any REAL failures (not cancellations)
        HAS_FAILURES=false
        HAS_CANCELLATIONS=false

        if [[ "$STRING_STATUS" == "failure" ]] || [[ "$BUILD_STATUS" == "failure" ]] || [[ "$LINT_STATUS" == "failure" ]]; then
          HAS_FAILURES=true
          HEADER="# ‚ö†Ô∏è CI Pipeline - Action Required"
        elif [[ "$STRING_STATUS" == "cancelled" ]] || [[ "$BUILD_STATUS" == "cancelled" ]] || [[ "$LINT_STATUS" == "cancelled" ]]; then
          HAS_CANCELLATIONS=true
          HEADER="# ‚ö†Ô∏è CI Pipeline - Run Superseded"
        else
          HEADER="# ‚úÖ CI Pipeline Results"
        fi

        # Start building report
        cat > build-report.md << EOF
        $HEADER

        ## Quality Checks
        - $STRING_EMOJI **String Validation**: $STRING_TEXT
        - $BUILD_EMOJI **Build & Test**: $BUILD_TEXT
        - $LINT_EMOJI **SwiftLint**: $LINT_TEXT

        EOF

        # Add performance metrics and coverage if build succeeded
        if [[ "$BUILD_STATUS" == "success" ]]; then
          cat >> build-report.md << 'EOF'
        ## üìä Performance Metrics
        Build and test performance data available in workflow artifacts.

        EOF

          # Try to extract coverage from test_coverage_report.md if available
          if [ -f "artifacts/test-results-and-coverage/test_coverage_report.md" ]; then
            COVERAGE_LINE=$(grep "Total Coverage" artifacts/test-results-and-coverage/test_coverage_report.md | head -1)
            if [ -n "$COVERAGE_LINE" ]; then
              echo "### Code Coverage" >> build-report.md
              echo "$COVERAGE_LINE" >> build-report.md
              echo "" >> build-report.md
              echo "üìÑ Full coverage breakdown available in the \`test-results-and-coverage\` artifact." >> build-report.md
              echo "" >> build-report.md
            fi
          fi
        fi

        # Add action required section if there are failures
        if [ "$HAS_FAILURES" = true ]; then
          cat >> build-report.md << 'EOF'
        ---

        ## üö® Action Required

        EOF

          if [[ "$STRING_STATUS" == "failure" ]]; then
            echo "### String Validation Failed" >> build-report.md
            echo "Some localized strings exceed length constraints. Check the \`string-validation-report\` artifact for details." >> build-report.md
            echo "" >> build-report.md
          fi

          if [[ "$BUILD_STATUS" == "failure" ]]; then
            echo "### Build or Tests Failed" >> build-report.md
            echo "Review build logs and test results in the \`test-results-and-coverage\` artifact." >> build-report.md
            echo "" >> build-report.md
          fi

          if [[ "$LINT_STATUS" == "failure" ]]; then
            echo "### SwiftLint Violations" >> build-report.md
            echo "Code style violations detected. Run \`swiftlint\` locally to see and fix violations." >> build-report.md
            echo "" >> build-report.md
          fi
        elif [ "$HAS_CANCELLATIONS" = true ]; then
          cat >> build-report.md << 'EOF'
        ---

        ## ‚ÑπÔ∏è Run Cancelled

        This workflow was automatically cancelled because a newer commit was pushed to the same branch.
        The newer workflow run contains the most up-to-date validation results.

        **No action required** - This is normal behavior when commits are pushed in quick succession.

        EOF
        fi

        # Add artifacts section
        cat >> build-report.md << 'EOF'
        ---

        ## üì¶ Artifacts
        Detailed reports available in workflow artifacts:
        - **string-validation-report** - Localization validation results
        - **test-results-and-coverage** - Test results, coverage data, and performance metrics
        - **build-report** - This comprehensive report

        EOF

        # Add timestamp
        echo "_Report generated on $(date -u '+%b %d, %Y at %H:%M:%S UTC')_" >> build-report.md
    
    - name: Upload Build Report
      uses: actions/upload-artifact@v4
      with:
        name: build-report
        path: |
          build-report.md
          artifacts/
        retention-days: 30
    
    - name: Comment PR (if applicable)
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const fs = require('fs');
          const report = fs.readFileSync('build-report.md', 'utf8');

          // Only post comment if there are real failures, not cancellations
          const hasFailures = report.includes('# ‚ö†Ô∏è CI Pipeline - Action Required');
          const hasSuccess = report.includes('# ‚úÖ CI Pipeline Results');

          if (hasFailures || hasSuccess) {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });
          }
          // Skip posting for cancelled/superseded runs to reduce noise

# Security: Limit permissions
permissions:
  contents: read
  issues: read
  pull-requests: write